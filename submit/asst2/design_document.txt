Questions

1. What are the ELF magic numbers?

    The first 4 bytes of e_indent, the array of bytes that specifies how the file should be interpreted, are 3x7f, 'E', 'L', 'F', respectively. The subsequent fields indicate the file class, data encoding, ELF version, OS/syscall ABI identification, and syscall ABI version.

2. What is the difference between UIO_USERISPACE and UIO_USERSPACE? When should one use UIO_SYSSPACE instead?

    UIO_USERISPACE and UIO_USERSPACE stand for user process code and user process data respectively. One should use UIO_SYSSPACE when moving data from... ????

3. Why can the struct uio that is used to read in a segment be allocated on the stack in load_segment() (i.e., where does the memory read actually go)?

4. In runprogram(), why is it important to call vfs_close() before going to usermode?

    Once we've loaded the executable, we no longer need a reference to the file. If we don't close the vnode before warpping to user mode in another process, we lose track of this file????

5. What function forces the processor to switch into usermode? Is this function machine dependent?

    enter_new_process(), located in trap.c, forces the processor to switch into usermode. It is machine dependent--Passing argc/argv may use additional stack space on some other platforms, but not on mips.

6. In what file are copyin and copyout defined? memmove? Why can't copyin and copyout be implemented as simply as memmove?

    copyin() and copyout() are defined in copyinout.c and memmove() is defined in memmove.c. copyin()/copyout() copies block of memory across user/kernel addresses, something that memmove() is not capable of doing.

7. What (briefly) is the purpose of userptr_t?

    A one-byte struct... (see copyin/out???)

kern/arch/mips: traps and syscalls
Questions

1. What is the numerical value of the exception code for a MIPS system call?

    #define EX_SYS 8

2. How many bytes is an instruction in MIPS? (Answer this by reading syscall() carefully, not by looking somewhere else.)

    4 bytes, the amount the program counter is advanced before syscall returns.

3. Why do you "probably want to change" the implementation of kill_curthread()?

    We don't want the kernel to panic when a user-level code hits a fatal fault.

4. What would be required to implement a system call that took more than 4 arguments?

    Additional arguments would need to be fetched from the user-level stack starting at sp+16.

Questions

1. What is the purpose of the SYSCALL macro?

    

2. What is the MIPS instruction that actually triggers a system call? (Answer this by reading the source in this directory, not looking somewhere else.)

3. After reading syscalls-mips.S and syscall.c, you should be prepared to answer the following question: OS/161 supports 64-bit values; lseek() takes and returns a 64-bit offset value. Thus, lseek() takes a 32-bit file handle (arg0), a 64-bit offset (arg1), a 32-bit whence (arg3), and needs to return a 64-bit offset value. In void syscall(struct trapframe *tf) where will you find each of the three arguments (in which registers) and how will you return the 64-bit offset?
